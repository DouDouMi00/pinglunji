import asyncio, time, re, traceback
import pygame._sdl2.audio as sdl2_audio
from .messages_handler import popMessagesQueue, getHaveReadMessages
from .stats import appendDelay
from .config import getJsonConfig
from .logger import timeLog
import winsdk.windows.media.speechsynthesis as speechsynthesis
import winsdk.windows.storage.streams as streams
import pygame
import io, json, os

channels = [{"lastRate": None, "lastVolume": None, "lastVoice": None, "synthesizer": speechsynthesis.SpeechSynthesizer()}] * 2
symbolToText = json.load(open(os.path.join(os.path.dirname(os.path.abspath(__file__)), '../symbol-to-text.json'), encoding='utf-8', mode='r'))
lastSpeaker = None
nowSpeaker = None
allVoices = []
allSpeakers = []
prepareDisableTTSTask = False
disableTTSTask = False
readHistoryIndex = None
initalized = False

def getAllVoices():
    global allVoices
    return [ { 'name': voice.display_name, 'language': voice.language } for voice in list(allVoices)]

def getAllSpeakers():
    global allSpeakers
    return allSpeakers

async def init():
    global synthesizer, allVoices, allSpeakers
    pygame.mixer.init()
    allSpeakers = sdl2_audio.get_audio_device_names(False)
    for name in list(allSpeakers):
        timeLog(f'[TTS] Found speaker: {name}')

    allVoices = speechsynthesis.SpeechSynthesizer.all_voices
    for voice in list(allVoices):
        timeLog(f'[TTS] Found voice: {voice.display_name} ({voice.language})"')

    await tts("TTS模块初始化成功")
    global initalized
    initalized = True

def syncSpeakerWithConfig():
    # 更新TTS音频通道
    global nowSpeaker, lastSpeaker
    ttsConfig = getJsonConfig()['dynamic']['tts']
    if lastSpeaker != ttsConfig['speaker']:
        lastSpeaker = ttsConfig['speaker']
        for speaker in list(allSpeakers):
            if ttsConfig['speaker'] in speaker:
                nowSpeaker = speaker
                break
        if nowSpeaker != None:
            timeLog(f'[TTS] Use speaker: {nowSpeaker}"')
        else:
            nowSpeaker = allSpeakers[0]
            timeLog(f'[TTS] Use default speaker: {nowSpeaker}"')
        for channel in range(len(channels)):
            pygame.mixer.Channel(channel).stop()
        pygame.mixer.quit()
        pygame.mixer.init(devicename=nowSpeaker)

def syncWithConfig(ttsConfig=None, channel=0):
    global channels, lastSpeaker
    if ttsConfig == None:
        ttsConfig = getJsonConfig()['dynamic']['tts']
    channelInfo = channels[channel]
    if channelInfo['lastVolume'] != ttsConfig['volume']:
        channelInfo['lastVolume'] = ttsConfig['volume']
        channelInfo['synthesizer'].options.audio_volume = channelInfo['lastVolume'] / 100.0
    if channelInfo['lastRate'] != ttsConfig['rate']:
        channelInfo['lastRate'] = ttsConfig['rate']
        # This value can range from 0.5 (half the default rate) to 6.0 (6x the default rate), inclusive.
        # The default value is 1.0 (the "normal" speaking rate for the current voice).
        channelInfo['synthesizer'].options.speaking_rate = 0.5 + (channelInfo['lastRate'] / 100.0) * 5.5
    if channelInfo['lastVoice'] != ttsConfig['voice']:
        channelInfo['lastVoice'] = ttsConfig['voice']
        targetVoice = None
        for voice in list(allVoices):
            if ttsConfig['voice'] in voice.display_name:
                targetVoice = voice
                break
        if targetVoice != None:
            timeLog(f'[TTS] Use voice: {targetVoice.display_name} ({targetVoice.language})"')
            channelInfo['synthesizer'].voice = targetVoice
        else:
            voice = channelInfo['synthesizer'].voice
            timeLog(f'[TTS] Use default voice: {voice.display_name} ({voice.language})"')

def getNowSpeaker():
    global nowSpeaker
    return nowSpeaker

def xmlEscape(text):
    return text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;')

def calculateTags(lang, config, text):
    tagsXml = '<voice name="{}" xml:lang="{}"><prosody rate="{}" volume="{}">{}</prosody></voice>'
    return tagsXml.format(config["voice"], lang, 0.5 + (config["rate"] / 100.0) * 2.5, config["volume"], text)

async def tts(text, channel=0, config=None):
    global synthesizer, channels
    syncWithConfig(config, channel)
    ttsConfig = getJsonConfig()['dynamic']['tts']
    # 标点符号处理
    if ttsConfig['readSymbolEnable']:
        text = "".join([symbolToText[char] if char in symbolToText else char for char in text])
    text = xmlEscape(text)

    ssml = f'<speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="zh-CN"><voice xml:lang="zh-CN">{text}</voice></speak>'
    # Synthesize text to a stream
    stream = await channels[channel]['synthesizer'].synthesize_ssml_to_stream_async(ssml)

    temp_buffer = bytes(0)
    data_reader = streams.DataReader(stream)
    await data_reader.load_async(stream.size)
    while data_reader.unconsumed_buffer_length > 0:
        temp_buffer += bytes(data_reader.read_buffer(data_reader.unconsumed_buffer_length)) + b'\x00\x00\x00\x00\x00\x00\x00\x00'

    byte_stream = io.BytesIO(temp_buffer)

    pygame.mixer.Channel(channel).stop()
    while pygame.mixer.Channel(channel).get_busy():
        await asyncio.sleep(0.01)
    
    pygame.mixer.Channel(channel).play(pygame.mixer.Sound(byte_stream))

    while pygame.mixer.Channel(channel).get_busy():
        await asyncio.sleep(0.01)

    stream.close()


def messagesToText(msg):
    if msg['type'] == 'danmu':
        return f"{msg['uname']}说{msg['msg']}"
    elif msg['type'] == 'gift':
        return f"感谢{msg['uname']}送出的{msg['num']}个{msg['giftName']}"
    elif msg['type'] == 'like':
        return f"感谢{msg['uname']}点赞"
    elif msg['type'] == 'welcome':
        return f"欢迎{msg['uname']}进入直播间"
    elif msg['type'] == 'system':
        return f"系统提示{msg['msg']}"

async def ttsTask():
    global prepareDisableTTSTask, disableTTSTask
    await init()
    while True:
        try:
            # 暂停TTS线程
            if prepareDisableTTSTask:
                disableTTSTask = True
                await asyncio.sleep(0.01)
                continue
            else:
                disableTTSTask = False
            syncSpeakerWithConfig()
            msg = popMessagesQueue()
            if msg == None:
                await asyncio.sleep(0.01)
                continue
            appendDelay(time.time() - msg['time'])
            text = messagesToText(msg)
            await tts(text)
        except Exception as e:
            if not isinstance(e, asyncio.CancelledError):
                traceback.print_exc()
                await asyncio.sleep(0.1)
            else:
                break

async def setDisableTTSTask(mode, waiting = True):
    global prepareDisableTTSTask, disableTTSTask
    if prepareDisableTTSTask == False and mode == True:
        prepareDisableTTSTask = mode
        while (not disableTTSTask) and waiting:
            await asyncio.sleep(0.01)
    elif prepareDisableTTSTask == True and mode == False:
        prepareDisableTTSTask = mode
        while (disableTTSTask) and waiting:
            await asyncio.sleep(0.01)

ttsSystemCallerID = 0
async def ttsSystem(msg):
    global initalized
    while not initalized:
        await asyncio.sleep(0.01)
    global ttsSystemCallerID
    ttsSystemCallerID += 1
    myCallerID = ttsSystemCallerID
    await setDisableTTSTask(True, False)
    syncSpeakerWithConfig()
    await tts(messagesToText({'type': 'system', 'msg': msg}))
    # 打断逻辑处理
    if ttsSystemCallerID != myCallerID:
        return
    await setDisableTTSTask(False, False)

async def readHistoryByType(types, revert=False):
    global readHistoryIndex
    if readHistoryIndex == None:
        readHistoryIndex = len(getHaveReadMessages())
    readHistoryIndex = (readHistoryIndex - 1) if not revert else (readHistoryIndex + 1)
    messages = getHaveReadMessages()
    found = False
    for i in range(readHistoryIndex, -1 if not revert else len(getHaveReadMessages()), -1 if not revert else 1):
        for type in types:
            if messages[i]['type'] == type:
                readHistoryIndex = i
                found = True
                break
        if found:
            break
    if (not revert and readHistoryIndex == -1) or (revert and readHistoryIndex > len(getHaveReadMessages())) or not found:
        if not revert:
            readHistoryIndex = len(getHaveReadMessages())
            await tts(messagesToText({'type': 'system', 'msg': '已到达最后一条,继续翻页将从第一条开始'}), 1, getJsonConfig()['dynamic']['tts']['history'])
        else:
            readHistoryIndex = 0
            await tts(messagesToText({'type': 'system', 'msg': '已到达第一条,继续翻页将从最后一条开始'}), 1, getJsonConfig()['dynamic']['tts']['history'])
        return
    await tts(messagesToText(messages[readHistoryIndex]), 1, getJsonConfig()['dynamic']['tts']['history'])

async def resetHistoryIndex():
    global readHistoryIndex
    readHistoryIndex = len(getHaveReadMessages())
    await tts(messagesToText({'type': 'system', 'msg': '焦点已回到最新'}), 1, getJsonConfig()['dynamic']['tts']['history'])